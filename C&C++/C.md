[TOC]

# Introduction
### 基础
- 数据类型
    - 基本类型
        - 字符`char`
        - 整型*
            - 均包括`signed` `unsigned`
        - 浮点*
    - 派生类型
        - 指针 提供与具体机器无关的地址算术运算
        - 数组
        - 结构`struct`
        - 联合`union`
- 控制流结构
    - 语句组`block`
    - 条件判断`if-else`
    - 多路选择`switch`
    - 循环*
    - 跳出循环
- 函数
    - 任何函数均可递归调用
    - 可以返回基本类型/结构/联合/指针类型的值
    - 函数的默认返回类型为int，可以省略
- 变量
    - 所有变量必须先声明后使用
        - 声明 说明变量，不分配存储单元
        - 定义 创建变量/分配存储单元
    - 局部变量
        - 未赋值时为无效值
    - 全局变量 可选`extern`
        - 同文件中声明且声明出现在定义之前可省略
    - 跨文件变量`extern`
- 预处理
    - 宏替换
    - 条件编译
    - 包含其他源文件

### 特性
- 除局部变量外提供的静态定义和堆栈外，没有定义任何存储器分配工具
- 不提供堆和内存回收
- 提供单线程控制流（测试、循环、分组、子程序）
- 不提供多道程序设计、并行操作、同步协同例程

### ANSI C
- 结构赋值
- 常量类型`const`
- 枚举定义
- 标准函数库
    - 访问操作系统
    - 标准输入输出
    - 内存分配
    - 字符串操作
- 不允许在指针和整型间交换值
- 要求对变量进行正确声明和显示强制类型转换


# 类型、运算符、表达式

### 变量名
- 由字母和数字组成，`_`看作字母，常用于命名长变量
- 库例程的名字首字母通常为下划线
- 变量名使用小写，符号常量名全部大写
- 内部名保证前31个字符有效
- 外部名ANSI仅保证前6个字符的唯一性，且不区分大小写
- 不能使用关键字

### 数据类型及长度
- `signed` `unsigned`可用于限定char和任意整型
- 不带限定符的char对象是否带符号取决于具体机器，但可打印字符总是正值，故当在`char`类型的变量中存储非字符数据时最好指定其符号限制符
- 整型和浮点型的长度取决于具体实现
- 有关类型长度定义的符号常量以及其他与机器和编译器有关的属性在标准库头文件`limits.h`和`float.h`中

### 常量
- `L`/`l`后缀可用于整型常量`123L`、浮点型常量`5.55L`以及各进制常量`0xFL`
- 整型常量
    - 默认为`int`
    - 若超过`int`表示范围或使用后缀`L`/`l`，则为`long`类型
- 浮点数
    - 通常包含小数点`1.23`或指数`3e-2`，也可两者均有
    - 默认为`double`
    - 后缀`F`/`f`表示为`float`
- 八进制，前缀`0`，如`031`
- 十六进制，前缀`0x`/`0X`，如`0x1f`
- 字符常量
    - 本质为一个整数，将字符用单引号包括
    - 在机器字符中的数值就是字符常量的值，如`0`的值为48
    - 用于增加程序可读性
    - 转义字符序列
        - 特殊转义，如`\n`
        - 八进制表示，`\ooo`，ooo为1-3个八进制数字
        - 十六进制表示，`\xhh`，hh为1-2个十六进制数字
- 常量表达式
    - 仅包含常量的表达式
    - 编译时求值
- 字符串常量/字符串字面值
    - 本质上是以`\0`结尾的字符数组，故对长度没有限制
        - 标准库函数`strlen(s)`返回不包括末尾`\0`的字符串长度
    - 表现为用双引号括起来的0或多个字符序列
    - 双引号只用于限定字符串，不是字符串内容
    - 编译时可以将多个字符串常量连接起来，中间无需操作符，可包含空白符
        - `"hello"  ","  "world"`
- 枚举（弱枚举，在支持强枚举类型时不推荐）
    - 常量整型值的列表，本质是自动生成的`#define`
    - 为建立常量值与名字之间的关联提供了便利的方式
    - 没有显式说明的情况下，第一个枚举名的值为0
    - 指定部分枚举名的值是，未指定的枚举值将依最后指定值递增
    - 不同枚举中的名字必须互不相同，同一枚举中不同名字可以为相同值
    - 缺点（对比强枚举）
        - 非强作用域类型
        - 可以隐式转换为整型，导致非期望转换

### 声明
- 局部变量
    - 每次到达声明时，显式初始化的变量将被初始化，未显式初始化的值未未定义值
    - 初始化表达式可以为任何表达式
- 全局变量
    - 在程序开始执行前被初始化，只能初始化一次
    - 未被显式初始化时被初始化为0
    - 初始化表达式必须为常量表达式

### 算术运算符
- 整数除法会阶段结果中小数部分
- 取模运算符不能应用于浮点类型
- 有负操作数的情况下，整数除法街区的方向及取模结果的符号取决于具体机器实现

### 类型转换
- 标准头文件`ctype.h`定义了一组与字符集无关的测试和转换函数

### 位运算符
- 按位与运算符`&`常用于频闭某些位
- 按位或运算符`|`常用于置位
- 对`signed`类型右移时，以具体实现分为算术移位（补符号位）和逻辑移位（补0）
    - `~`常用与获得与机器实际字长无关的字段如使用`x & ~077`而不是使用`x & 0177700`这种假设x为16位的表达式形式

### 运算优先级与求值次序
- 编程中，避免使用执行结果与求值顺序相关的代码
- C语言没有规定同一运算符中多个操作数的计算顺序
    - 如`sum = f() + g();`中，两个函数的调用顺序没有要求，如果它们依赖于某一全局变量，则可能得到不是预期的结果
- C语言没有规定函数参数的求值顺序
    - 如`printf("%d%d",++n,pow(2,n));`中，pow函数的调用的次序可能在n变量的值变化之前也可能在之后
- 表达式求值时可能存在副作用
    - `a[i] = i++;`中，访问下标引用的是否为新值取决于具体实现


# 控制流

...


# 函数与程序结构

### 静态变量
- 用`static`声明的外部变量和函数的作用域将被限定为其所在文件的剩余部分，从而达到对其他文件隐藏外部对象的目的
- 用`static`声明的自动变量是一种只能在其所在函数中使用，但一直占据存储空间的变量

### 寄存器变量
- `register`声明向编译器提出建议，指出其声明的变量在程序中使用频率较高，应将其存放在寄存器中
- 编译器可以忽略此选项
- `register`声明只适用于自动变量和函数的形式参数
- 无论被声明后的寄存器变量是否存放在寄存器中，其地址均不能访问

### C预处理器
#### 文件包含
- 使用`#include`来将依赖的内容包含到当前文件中
- 当文件名用`< >`括起来时，预处理器将在由具体实现定义的有关位置查找指定的文件（unix系统中，文件通常存放在`/usr/include`中
- 当文件名用`" "`括起来时，预处理器将在当前文件所在位置查找指定的文件，若没有找到，再按照`< >`进行查找

#### 宏定义
- `#define`指令中的名字与变量名命名方式相同
- 替换文本可以是任意字符串
- 默认情况下，替换文本是指令行尾部所有剩余字符
- 可以通过在行尾添加`\`将其延长到下一行以增加可读性
- 宏定义可以使用前面出现的宏定义
- 可以通过`#undef`指令来取消宏定义
- 替换只对记号进行，对引号中的字符串不起作用
    - 如`#define OK 0` 不对 `printf("OK");` 进行替换

```cpp
//下面的宏在表达式AB存在副作用时是错误的
#define max(A, B) ((A) > (B) ? (A) : (B))
//如
max(++i, ++j);

//在替换文本中，参数名以#作为前缀时，结果将被扩展为实际参数的字符串
#define p(expr)  printf(#expr " = %d", expr)
//以下语句的输出结果为 30/3 = 10
p(30/3);

//预处理器运算符##提供了一种连接实际参数的手段
//如果替换文本中的参数与##相邻，参数将被实际参数替换，且去除前后空白符
#define paste(front, back) front ## back
//下面的语句得到标记name1
paste(name, 1)
//可作为正常变量名操作
paste(name, 1) = "xxx";
//##的嵌套使用规则较复杂，不建议使用
```

#### 条件包含
- 提供了一种在编译过程中根据特定条件选择性包含不同代码的方式
- 避免重复包含同一文件，不必考虑和处理头文件之间的依赖关系


# 指针与数组
- 指针是一种保存变量地址的变量
- `void*`用作通用指针类型
- 通过数组下标能完成的任何操作，都可以通过指针来实现
- 不同
    - 指针是变量，可以赋值给指针
    - 数组名不是变量，不能赋值给数组本身
- 如果将二维数组作为参数传递给函数，在参数声明中必须指明数组列数


# 结构

#### typedef
- 表达简洁
- 提供更好的可读性
- 使程序参数化，提高程序可移植性，将同机器有关的数据结构使用typedef声明，移植后秩序修改typedef定义

#### union
- 多数情况下不建议使用
- 应使用c++17 `variant`获得更好的支持

#### 位字段
- 不建议使用
- 应使用`bitset`代替


